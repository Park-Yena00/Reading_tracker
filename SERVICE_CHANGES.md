# 서비스 기획 및 구현 변경사항 정리

> **작성일**: 2025-01-28  
> **목적**: 초기 기획과 실제 구현 과정에서 변경된 서비스 측면의 주요 사항을 정리

---

## 목차

1. [개요](#개요)
2. [주요 서비스 변경사항](#주요-서비스-변경사항)
3. [기능 추가 및 확장](#기능-추가-및-확장)
4. [아키텍처 변경](#아키텍처-변경)
5. [성능 및 품질 개선](#성능-및-품질-개선)
6. [비기능 요구사항 추가](#비기능-요구사항-추가)
7. [종합 요약](#종합-요약)

---

## 개요

본 문서는 Reading Tracker 프로젝트의 초기 기획 단계에서 계획했던 서비스와 실제 구현 과정에서 변경되거나 추가된 서비스 측면의 주요 사항을 정리합니다.

### 초기 기획의 핵심 서비스

1. **인증 및 사용자 관리**: JWT 기반 인증, 회원가입, 로그인, 비밀번호 재설정
2. **도서 검색 및 관리**: 알라딘 API 연동 도서 검색, 서재 관리
3. **독서 메모**: 메모 작성, 수정, 삭제, 태그 시스템
4. **오늘의 흐름**: 날짜별 메모 조회 (세션/책/태그 모드)

### 구현 과정에서의 주요 변화

초기 기획에서는 **온라인 환경에서만 동작하는 기본적인 독서 관리 서비스**를 목표로 했으나, 구현 과정에서 **Fault Tolerance(장애 허용)** 비기능 품질 개선을 통해 다음과 같은 주요 변경이 이루어졌습니다:

1. **오프라인 지원 기능 추가**: 네트워크가 없는 환경에서도 메모 작성 가능
2. **데이터베이스 이중화**: MySQL Dual Master 구성으로 고가용성 확보
3. **하이브리드 전략 도입**: Offline-First에서 온라인/오프라인 하이브리드 전략으로 전환
4. **성능 최적화**: 로그인, 도서 상세 정보 화면 등 주요 기능의 성능 개선
5. **데이터 무결성 보장**: 멱등성 키, Recovery Queue 등을 통한 데이터 일관성 보장

---

## 주요 서비스 변경사항

### 1. 오프라인 메모 동기화 기능 추가

#### 초기 기획
- **온라인 환경에서만 동작**: 네트워크 연결이 필수
- **서버 중심 아키텍처**: 모든 데이터는 서버에 저장
- **오프라인 상태에서 메모 작성 불가능**

#### 변경 후
- **오프라인 환경 지원**: 네트워크가 없는 환경에서도 메모 작성 가능
- **클라이언트 측 저장소 활용**: IndexedDB를 통한 로컬 저장
- **자동 동기화**: 네트워크 복구 시 자동으로 서버에 동기화
- **동기화 큐 관리**: PENDING → SYNCING → COMPLETED/FAILED 상태 관리
- **Service Worker 지원**: 백그라운드 동기화 가능

**영향 범위:**
- 프론트엔드: IndexedDB 스키마 설계, 동기화 큐 관리, 네트워크 상태 모니터링
- 백엔드: 멱등성 키 지원 (Redis), 동시성 제어

**서비스 가치:**
- 사용자가 네트워크 환경에 관계없이 언제든지 메모 작성 가능
- 사용자 경험 향상: 오프라인 상태에서도 서비스 이용 가능

---

### 2. MySQL Dual Master 구성 추가

#### 초기 기획
- **단일 데이터베이스**: Primary DB만 사용
- **데이터베이스 장애 시 서비스 중단**: DB 장애 시 전체 서비스 불가능

#### 변경 후
- **Dual Master 구성**: Primary DB와 Secondary DB 동시 운영
- **Read Failover**: Primary DB 장애 시 Secondary DB로 자동 전환
- **Dual Write**: 모든 Write 작업을 양쪽 DB에 동시 실행
- **보상 트랜잭션**: Write 실패 시 양쪽 DB 모두 롤백하여 데이터 일관성 보장
- **Recovery Queue**: Secondary DB 실패 시 유령 데이터 정리를 위한 비동기 복구 메커니즘

**영향 범위:**
- 백엔드: 모든 Service 메서드 수정 (17개), 커스텀 트랜잭션 매니저 구현
- 인프라: Docker Compose를 통한 Secondary DB 구성

**서비스 가치:**
- 고가용성: 데이터베이스 장애 시에도 서비스 지속 가능
- 데이터 일관성: Dual Write 및 보상 트랜잭션을 통한 데이터 무결성 보장

---

### 3. 하이브리드 전략 도입

#### 초기 기획
- **온라인 전용**: 모든 작업은 서버와의 통신 필요
- **단순한 아키텍처**: 클라이언트 → 서버 → DB 구조

#### 변경 후
- **하이브리드 전략**: 온라인/오프라인 상태에 따라 다른 전략 적용
  - **온라인**: 서버 우선 처리 → IndexedDB 갱신
  - **오프라인**: 로컬 우선 처리 → 동기화 큐 추가
- **상태 전환 처리**: NetworkStateManager를 통한 중앙화된 상태 관리
- **이벤트 기반 처리**: Event-Driven 패턴을 통한 느슨한 결합

**영향 범위:**
- 프론트엔드: 하이브리드 전략 로직, 상태 전환 처리, 이벤트 기반 아키텍처
- 코드 구조: 공통 로직 추출 (MemoOperationHelper), 코드 중복 30-40% 감소

**서비스 가치:**
- 유연성: 네트워크 상태에 관계없이 최적의 사용자 경험 제공
- 확장성: 이벤트 기반 처리로 새로운 기능 추가 용이

---

## 기능 추가 및 확장

### 1. 멱등성 보장 기능 추가

#### 초기 기획
- **멱등성 보장 없음**: 동일한 요청이 여러 번 처리될 수 있음

#### 변경 후
- **Redis 기반 멱등성 키**: 동일한 요청의 중복 처리 방지
- **클라이언트 측 멱등성 키 관리**: 동기화 큐 항목별 고정된 멱등성 키 저장
- **Service Worker 멱등성 키 지원**: 백그라운드 동기화 시에도 멱등성 보장

**서비스 가치:**
- 데이터 무결성: 동일한 메모가 중복 생성되지 않도록 보장
- 안정성: 네트워크 재시도 시에도 중복 처리 방지

---

### 2. Recovery Queue 추가

#### 초기 기획
- **Recovery Queue 없음**: Secondary DB 실패 시 유령 데이터 정리 불가능

#### 변경 후
- **Recovery Queue**: Secondary DB 실패 시 유령 데이터 정리를 위한 비동기 복구 메커니즘
- **이벤트 기반 복구**: CompensationFailureEvent를 통한 복구 작업 큐잉
- **비동기 복구 처리**: Recovery Worker를 통한 백그라운드 복구

**서비스 가치:**
- 데이터 일관성: Secondary DB의 유령 데이터를 자동으로 정리
- 장기적 안정성: 데이터베이스 간 데이터 불일치 문제 해결

---

### 3. 네트워크 에러 처리 개선

#### 초기 기획
- **단순한 에러 처리**: 네트워크 에러 시 로그아웃 처리

#### 변경 후
- **네트워크 에러와 인증 에러 구분**: 
  - 네트워크 에러: 일시적 문제 → 토큰 유지, 인증 상태만 초기화
  - 인증 에러(401): 영구적 문제 → 로그아웃 처리
- **오프라인 메모 동기화 지원**: 서버 재시작 후에도 토큰이 있으면 자동 동기화 가능

**서비스 가치:**
- 사용자 경험 향상: 불필요한 재로그인 방지
- 오프라인 동기화 지원: 서버 재시작 후에도 오프라인 메모 자동 동기화

---

### 4. 토큰 갱신 로직 개선

#### 초기 기획
- **401 에러에서만 토큰 갱신**: Access Token 만료 시 401 에러에서만 갱신 시도

#### 변경 후
- **403 에러에서도 토큰 갱신**: Access Token 만료로 인한 403 에러에서도 토큰 갱신 시도
- **자동 재시도**: 토큰 갱신 성공 시 원래 요청 자동 재시도
- **Redis 기반 RefreshToken**: Token Rotation 방식으로 보안 강화

**서비스 가치:**
- 사용자 경험 향상: 토큰 만료 시 자동 갱신 및 재시도
- 보안 강화: Token Rotation 방식으로 토큰 보안 강화

---

## 아키텍처 변경

### 1. 3-tier Architecture 유지 및 확장

#### 초기 기획
- **기본 3-tier Architecture**: Client ↔ Server ↔ DBMS
- **단일 데이터베이스**: Primary DB만 사용

#### 변경 후
- **3-tier Architecture 유지**: 기본 구조는 동일하게 유지
- **Dual Master 확장**: Server ↔ DBMS 경계에서 Primary/Secondary DB 지원
- **경계별 DTO 분리 유지**: ClientServerDTO, ServerDbmsDTO 분리 유지

**아키텍처 원칙 준수:**
- ✅ 경계 중심 패키지 분리 유지
- ✅ DTO 분리 원칙 유지
- ✅ MapStruct 기반 매퍼 아키텍처 유지

---

### 2. 프론트엔드 아키텍처 확장

#### 초기 기획
- **단순한 클라이언트 구조**: 서버와의 통신만 담당

#### 변경 후
- **Offline-First 아키텍처**: IndexedDB를 통한 로컬 저장소 활용
- **Service Worker 지원**: 백그라운드 동기화
- **이벤트 기반 아키텍처**: Event-Driven 패턴 도입
- **상태 관리 중앙화**: NetworkStateManager를 통한 네트워크 상태 관리

**아키텍처 원칙:**
- Event-Driven 패턴: IMPLEMENTATION_PLAN.md의 4번 원칙 준수
- 점진적 구현: 단계별 구현 및 테스트
- 함수 단일 책임 원칙: 공통 로직 추출

---

## 성능 및 품질 개선

### 1. 로그인 성능 최적화

#### 초기 구현
- **로그인 응답 시간**: 약 2.99초
- **동기적 처리**: 디바이스 정보 및 Refresh Token 저장이 로그인 응답을 블로킹

#### 개선 후
- **로그인 응답 시간**: 약 0.8-1.5초 (약 50-67% 개선)
- **비동기 처리**: 디바이스 정보 및 Refresh Token 저장을 비동기로 처리
- **프론트엔드 최적화**: 불필요한 디버깅 로그 제거, 리다이렉트 지연 제거

**개선 사항:**
- 프론트엔드: 디버깅 로그 제거 (~50-100ms), 토큰 저장 확인 간소화 (~10-20ms), 리다이렉트 지연 제거 (500ms)
- 백엔드: 비동기 처리 (~100-200ms)

---

### 2. 도서 세부 정보 화면 성능 최적화

#### 초기 구현
- **로딩 시간**: 약 500-800ms
- **순차적 API 호출**: 두 개의 API가 순차적으로 실행

#### 개선 후
- **로딩 시간**: 약 300-500ms (약 30-50% 개선)
- **병렬 API 호출**: Promise.all을 사용하여 두 API를 병렬로 실행

**개선 사항:**
- 순차적 → 병렬 API 호출: ~200-400ms 개선
- 불필요한 디버깅 로그 제거: ~1-2ms 개선

---

### 3. 코드 품질 개선

#### 초기 구현
- **코드 중복**: 각 메서드마다 IndexedDB 갱신 로직 중복
- **상태 전환 처리**: 각 서비스에서 개별적으로 상태 전환 처리

#### 개선 후
- **코드 중복 감소**: 공통 로직 추출로 약 30-40% 감소
- **상태 전환 처리 중앙화**: NetworkStateManager를 통한 중앙화된 상태 관리
- **이벤트 기반 처리**: 느슨한 결합으로 확장성 향상

**개선 사항:**
- MemoOperationHelper: 공통 로직 추출
- NetworkStateManager: 상태 전환 처리 중앙화
- Event-Driven 패턴: 이벤트 기반 처리

---

## 비기능 요구사항 추가

### 1. Fault Tolerance (장애 허용)

#### 초기 기획
- **Fault Tolerance 없음**: 장애 발생 시 서비스 중단

#### 추가된 기능
- **오프라인 메모 동기화**: 네트워크 장애 시에도 메모 작성 가능
- **Read Failover**: Primary DB 장애 시 Secondary DB로 자동 전환
- **Dual Write**: 데이터베이스 이중화를 통한 고가용성

**서비스 가치:**
- 가용성 향상: 장애 발생 시에도 서비스 지속 가능
- 사용자 경험 향상: 네트워크/데이터베이스 장애에 대한 투명한 처리

---

### 2. 데이터 일관성 보장

#### 초기 기획
- **기본적인 트랜잭션 관리**: 단일 DB 환경에서의 트랜잭션 관리

#### 추가된 기능
- **Dual Write**: 양쪽 DB에 동시 쓰기
- **보상 트랜잭션**: Write 실패 시 양쪽 DB 모두 롤백
- **멱등성 보장**: Redis를 통한 중복 처리 방지
- **Recovery Queue**: Secondary DB 유령 데이터 정리

**서비스 가치:**
- 데이터 무결성: 데이터베이스 간 데이터 일관성 보장
- 안정성: 중복 처리 및 데이터 불일치 문제 해결

---

### 3. 성능 최적화

#### 초기 기획
- **기본적인 성능**: 기능 구현 우선, 성능 최적화는 후순위

#### 추가된 기능
- **비동기 처리**: 로그인 시 디바이스/토큰 저장 비동기화
- **병렬 API 호출**: 도서 세부 정보 화면의 API 호출 병렬화
- **코드 최적화**: 불필요한 로그 제거, 중복 검증 제거

**서비스 가치:**
- 사용자 경험 향상: 응답 시간 단축
- 시스템 효율성: 리소스 활용 최적화

---

## 종합 요약

### 초기 기획 vs 최종 구현 비교

| 측면 | 초기 기획 | 최종 구현 | 변경 이유 |
|------|----------|----------|----------|
| **네트워크 의존성** | 온라인 전용 | 오프라인 지원 추가 | 사용자 경험 향상 |
| **데이터베이스 구성** | 단일 DB | Dual Master | 고가용성 확보 |
| **아키텍처 전략** | 서버 중심 | 하이브리드 전략 | 유연성 및 확장성 |
| **성능 최적화** | 기본 수준 | 주요 기능 최적화 | 사용자 경험 향상 |
| **데이터 일관성** | 기본 트랜잭션 | 멱등성, Recovery Queue | 데이터 무결성 보장 |
| **Fault Tolerance** | 없음 | 오프라인 동기화, Read Failover | 서비스 안정성 |

### 주요 성과

1. **서비스 가용성 향상**
   - 오프라인 환경에서도 메모 작성 가능
   - 데이터베이스 장애 시에도 서비스 지속 가능

2. **데이터 무결성 보장**
   - Dual Write 및 보상 트랜잭션을 통한 데이터 일관성
   - 멱등성 보장을 통한 중복 처리 방지

3. **성능 개선**
   - 로그인: 2.99초 → 0.8-1.5초 (약 50-67% 개선)
   - 도서 세부 정보: 500-800ms → 300-500ms (약 30-50% 개선)

4. **코드 품질 향상**
   - 코드 중복 30-40% 감소
   - 이벤트 기반 아키텍처로 확장성 향상

5. **사용자 경험 개선**
   - 네트워크 상태에 관계없이 서비스 이용 가능
   - 불필요한 재로그인 방지
   - 자동 토큰 갱신 및 재시도

### 학습한 내용

1. **Fault Tolerance 설계**: 오프라인 지원, 데이터베이스 이중화
2. **분산 시스템 설계**: Dual Write, 보상 트랜잭션, Recovery Queue
3. **성능 최적화**: 비동기 처리, 병렬 API 호출
4. **아키텍처 패턴**: Event-Driven, 하이브리드 전략
5. **데이터 일관성**: 멱등성 보장, 동시성 제어

---

## 참고 문서

- `README.md`: 프로젝트 개요 및 주요 기능
- `docs/fault-tolerance/FAULT_TOLERANCE_IMPLEMENTATION_ROADMAP.md`: Fault Tolerance 구현 로드맵
- `docs/fault-tolerance/OFFLINE_MEMO_SYNC.md`: 오프라인 메모 동기화 설계
- `docs/architecture/ARCHITECTURE.md`: 아키텍처 설계 원칙
- `TROUBLESHOOTING_STAR.md`: 주요 troubleshooting 문제 해결 과정

---

**작성일**: 2025-01-28

