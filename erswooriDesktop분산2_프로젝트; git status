package com.readingtracker.server.service;

import com.readingtracker.dbms.entity.Memo;
import com.readingtracker.dbms.entity.Tag;
import com.readingtracker.dbms.entity.TagCategory;
import com.readingtracker.dbms.entity.User;
import com.readingtracker.dbms.entity.UserShelfBook;
import com.readingtracker.dbms.repository.MemoRepository;
import com.readingtracker.dbms.repository.UserShelfBookRepository;
import com.readingtracker.server.common.constant.BookCategory;
import com.readingtracker.server.dto.responseDTO.BookMemoGroup;
import com.readingtracker.server.dto.responseDTO.MemoResponse;
import com.readingtracker.server.dto.responseDTO.TagMemoGroup;
import com.readingtracker.server.mapper.MemoMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

@Service
@Transactional
public class MemoService {
    
    @Autowired
    private MemoRepository memoRepository;
    
    @Autowired
    private MemoMapper memoMapper;
    
    @Autowired
    private UserShelfBookRepository userShelfBookRepository;
    
    /**
     * 메모 작성
     * - 메모 내용 필수 검증
     * - 태그 자동 생성 및 연결
     * - 페이지당 메모 개수 제한 없음 (사용자가 자유롭게 기록 가능)
     * - pageNumber: 메모 작성 시점의 SESSION 모드 기준 초기 위치를 저장 (정렬 방식 변경 시에도 변경하지 않음)
     * 
     * 참고: ARCHITECTURE 원칙에 따라 Entity만 사용합니다.
     * RequestDTO → Entity 변환은 Mapper 계층에서 처리됩니다.
     */
    public Memo createMemo(User user, Memo memo) {
        // 1. UserShelfBook 소유권 확인
        UserShelfBook userShelfBook = memo.getUserShelfBook();
        if (userShelfBook == null) {
            throw new IllegalArgumentException("책을 찾을 수 없습니다.");
        }
        
        if (!userShelfBook.getUserId().equals(user.getId())) {
            throw new IllegalArgumentException("권한이 없습니다.");
        }
        
        // 2. 태그 처리 확인
        // 태그는 Mapper에서 이미 Tag 엔티티 리스트로 변환되어 Entity에 설정됨
        // 추가 검증이 필요한 경우 여기서 수행
        
        // 3. Memo 엔티티 저장
        memo.setUser(user);
        return memoRepository.save(memo);
    }
    
    /**
     * 메모 수정
     * 
     * 참고: ARCHITECTURE 원칙에 따라 Entity만 사용합니다.
     * RequestDTO → Entity 변환은 Mapper 계층에서 처리됩니다.
     */
    public Memo updateMemo(User user, Long memoId, Memo memo) {
        // 1. 메모 조회 및 소유권 확인
        Memo existingMemo = memoRepository.findById(memoId)
            .orElseThrow(() -> new IllegalArgumentException("메모를 찾을 수 없습니다."));
        
        if (!existingMemo.getUser().getId().equals(user.getId())) {
            throw new IllegalArgumentException("권한이 없습니다.");
        }
        
        // 2. 필드 업데이트 (content와 tags만 수정 가능)
        // 참고: pageNumber는 메모 작성 시점의 시작 위치를 나타내는 메타데이터이므로 수정 불가
        // Mapper에서 이미 변환된 Entity의 필드만 업데이트
        // Mapper의 updateMemoFromRequest에서 이미 필드가 업데이트되었으므로 여기서는 저장만 수행
        
        return memoRepository.save(existingMemo);
    }
    
    /**
     * 메모 조회 (내부 사용)
     */
    @Transactional(readOnly = true)
    public Memo getMemoById(User user, Long memoId) {
        Memo memo = memoRepository.findById(memoId)
            .orElseThrow(() -> new IllegalArgumentException("메모를 찾을 수 없습니다."));
        
        if (!memo.getUser().getId().equals(user.getId())) {
            throw new IllegalArgumentException("권한이 없습니다.");
        }
        
        return memo;
    }
    
    /**
     * 메모 삭제
     */
    public void deleteMemo(User user, Long memoId) {
        Memo memo = memoRepository.findById(memoId)
            .orElseThrow(() -> new IllegalArgumentException("메모를 찾을 수 없습니다."));
        
        if (!memo.getUser().getId().equals(user.getId())) {
            throw new IllegalArgumentException("권한이 없습니다.");
        }
        
        memoRepository.delete(memo);
    }
    
    /**
     * 날짜 범위 계산 헬퍼 메서드
     * 
     * LocalDate를 LocalDateTime 범위로 변환합니다.
     * 향후 타임존 지원을 위해 구조화되어 있습니다.
     * 
     * 현재 구현: 서버 타임존 기준으로 처리
     * 향후 확장: 사용자 타임존 정보를 받아 해당 타임존 기준으로 계산 가능
     * 
     * @param date 조회할 날짜
     * @return 날짜 범위 (startOfDay, startOfNextDay)를 담은 배열
     */
    private LocalDateTime[] calculateDateRange(LocalDate date) {
        // 현재: 서버 타임존 기준으로 처리
        // 향후: 사용자 타임존을 받아 처리할 수 있도록 구조화
        // 예: ZoneId userTimeZone = getUserTimeZone(user);
        //     ZonedDateTime startOfDay = date.atStartOfDay(userTimeZone);
        //     return new LocalDateTime[] { 
        //         startOfDay.toLocalDateTime(), 
        //         startOfDay.plusDays(1).toLocalDateTime() 
        //     };
        
        LocalDateTime startOfDay = date.atStartOfDay();
        LocalDateTime startOfNextDay = date.plusDays(1).atStartOfDay();
        return new LocalDateTime[] { startOfDay, startOfNextDay };
    }
    
    /**
     * 오늘의 흐름 조회 (책별 그룹화)
     * 
     * 기능:
     * - 오늘 날짜의 메모 조회 (기본값)
     * - 과거 날짜의 메모 조회 가능 (독서 캘린더 연동)
     * - 책별로 그룹화하여 반환
     * - 각 책 그룹 내에서 타임라인 순으로 정렬 (memo_start_time 기준)
     * 
     * 백엔드 책임:
     * - Repository: book_id를 기준으로 데이터를 조회
     * - Service: 데이터를 책별로 그룹화하는 최종 변환 담당
     * 
     * 참고: 노션 문서 (https://www.notion.so/29c4a8c850098058892bc37ed7f6f68a)
     */
    @Transactional(readOnly = true)
    public Map<Long, BookMemoGroup> getTodayFlowGroupedByBook(User user, LocalDate date) {
        LocalDateTime[] dateRange = calculateDateRange(date);
        List<Memo> memos = memoRepository.findByUserIdAndDateOrderByBookAndMemoStartTimeAsc(
            user.getId(), dateRange[0], dateRange[1]
        );
        
        // 책별로 그룹화
        return memos.stream()
            .collect(Collectors.groupingBy(
                m -> m.getUserShelfBook().getId(),
                Collectors.collectingAndThen(
                    Collectors.toList(),
                    memoList -> {
                        BookMemoGroup group = new BookMemoGroup();
                        Memo firstMemo = memoList.get(0);
                        group.setBookId(firstMemo.getUserShelfBook().getId());
                        group.setBookTitle(firstMemo.getUserShelfBook().getBook().getTitle());
                        group.setBookIsbn(firstMemo.getUserShelfBook().getBook().getIsbn());
                        group.setMemos(memoMapper.toMemoResponseList(memoList));
                        group.setMemoCount(memoList.size());
                        return group;
                    }
                )
            ));
    }
    
    /**
     * 오늘의 흐름 조회 (태그별 그룹화)
     * 
     * 기능:
     * - 태그별로 그룹화하여 반환 (1차 그룹화)
     * - 각 태그 그룹 내부에서 책별로 다시 그룹화 (2차 그룹화)
     * - 각 책 그룹 내에서 타임라인 순으로 정렬 (3차 정렬)
     * 
     